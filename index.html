

Here is the updated code. I have modified the logic to:

1.  **Match Upload Size:** The canvas now adopts the exact resolution (width/height) of the uploaded image, ensuring a 1:1 quality export without cropping.
2.  **3x Enlargement:** The Geotag box and text size are calculated dynamically. They are scaled based on the image size and multiplied by **3**, making them significantly larger and more prominent as requested.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Geotag Editor</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-color: #f3f4f6;
            --card-bg: #ffffff;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --border-color: #e5e7eb;
            --radius-lg: 12px;
            --radius-md: 8px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--card-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        header h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-main);
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 2rem;
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        @media (max-width: 900px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-main);
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .file-upload-wrapper {
            position: relative;
            width: 100%;
            height: 100px;
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #fafafa;
        }

        .file-upload-wrapper:hover {
            border-color: var(--primary-color);
            background: #eff6ff;
        }

        .file-upload-wrapper input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .color-picker-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
        }

        .btn {
            display: block;
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            transition: background 0.2s;
        }

        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .btn:disabled {
            background-color: #cbd5e1;
            cursor: not-allowed;
        }

        .preview-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Allow scrolling if image is tall */
            background: #e5e5e5;
            border-radius: var(--radius-lg);
            padding: 1rem;
            overflow: auto; /* Handle large images */
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            min-height: 400px;
        }
        
        .canvas-container {
            line-height: 0;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            background: transparent; /* Show full image */
        }

        canvas {
            max-width: 100%;
            height: auto;
            display: block;
        }
        
        .empty-state {
            text-align: center;
            color: var(--text-muted);
            margin-top: 100px;
        }

        .loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            z-index: 10;
        }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: #1f2937;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius-md);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            transform: translateY(150%);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
        }
        
        .toast.show {
            transform: translateY(0);
        }
    </style>
</head>
<body>

    <header>
        <h1>Big Geotag Editor <span style="font-weight:normal; font-size:0.8em; color:gray;">(Original Resolution)</span></h1>
    </header>

    <main>
        <section class="controls">
            <div class="control-group">
                <label>Upload Photo</label>
                <div class="file-upload-wrapper">
                    <input type="file" id="imageInput" accept="image/png, image/jpeg">
                    <div style="font-size:1.5rem;">ðŸ“·</div>
                    <div style="font-size:0.875rem; color:var(--text-muted);">Click to Upload Image</div>
                </div>
            </div>

            <div class="control-group">
                <label>Main Label (e.g., MASUK 09:30)</label>
                <input type="text" id="timeLabel" value="MASUK 09:30">
            </div>

            <div class="control-group">
                <label>Date</label>
                <input type="text" id="dateLabel" value="24 January 2024">
            </div>

            <div class="control-group">
                <label>Address</label>
                <input type="text" id="addressLabel" value="Jl. Tebet Barat Raya No.1, RW.10, Jakarta 12820">
            </div>

            <div class="control-group">
                <label>Colors</label>
                <div class="color-picker-row">
                    <div class="color-item">
                        <input type="color" id="accentColor" value="#fbbf24">
                        <label>Accent</label>
                    </div>
                    <div class="color-item">
                        <input type="color" id="bgCardColor" value="#ffffff">
                        <label>BG</label>
                    </div>
                    <div class="color-item">
                        <input type="color" id="textColor" value="#1f2937">
                        <label>Text</label>
                    </div>
                </div>
            </div>

            <button id="downloadBtn" class="btn" disabled>Download Image</button>
        </section>

        <section class="preview-area">
            <div class="canvas-container">
                <canvas id="outputCanvas"></canvas>
                <div id="emptyState" class="empty-state">
                    <h3>No Image</h3>
                    <p>Upload a photo to edit.</p>
                </div>
            </div>
            <div id="loadingOverlay" class="loading-overlay">Processing...</div>
        </section>
    </main>

    <div id="toast" class="toast">Download started!</div>

    <script>
        // --- Configuration ---
        // Base design constants (reference for 2560px width)
        const BASE_WIDTH = 2560; 
        const BASE_CARD_WIDTH = 650;
        const BASE_FONT_LABEL = 48;
        const BASE_FONT_DATE = 32;
        const BASE_FONT_ADDR = 36;
        const ZOOM_MULTIPLIER = 3; // Requested: Perbesar 3x

        const FONT_FAMILY = "'Inter', -apple-system, sans-serif";

        // --- Elements ---
        const imageInput = document.getElementById('imageInput');
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        const emptyState = document.getElementById('emptyState');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const toast = document.getElementById('toast');

        // Inputs
        const timeLabelInput = document.getElementById('timeLabel');
        const dateLabelInput = document.getElementById('dateLabel');
        const addressLabelInput = document.getElementById('addressLabel');
        const accentColorInput = document.getElementById('accentColor');
        const bgCardColorInput = document.getElementById('bgCardColor');
        const textColorInput = document.getElementById('textColor');

        let currentImage = null;

        // --- Event Listeners ---
        imageInput.addEventListener('change', handleImageUpload);
        
        const inputs = [timeLabelInput, dateLabelInput, addressLabelInput, accentColorInput, bgCardColorInput, textColorInput];
        inputs.forEach(input => input.addEventListener('input', () => requestAnimationFrame(drawCanvas)));

        downloadBtn.addEventListener('click', downloadImage);

        // --- Functions ---

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            loadingOverlay.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    
                    // Set canvas size to EXACT uploaded image size
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    emptyState.style.display = 'none';
                    downloadBtn.disabled = false;
                    
                    drawCanvas();
                    loadingOverlay.style.display = 'none';
                };
                img.onerror = () => {
                    showToast('Error loading image');
                    loadingOverlay.style.display = 'none';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function drawCanvas() {
            if (!currentImage) return;

            // 1. Draw Original Image (Full Resolution)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // 2. Draw Geotag
            drawGeotagCard();
        }

        function drawGeotagCard() {
            // Calculate Scale Factor
            // 1. Ratio of current width to base width (2560)
            // 2. Multiplied by User Request (3x)
            const widthRatio = canvas.width / BASE_WIDTH;
            const scale = widthRatio * ZOOM_MULTIPLIER;

            // Layout Dimensions (Dynamic)
            const padding = 80 * scale;
            const cardWidth = BASE_CARD_WIDTH * scale;
            const cardPadding = 40 * scale;
            const lineWidth = 6 * scale;
            const accentLineHeight = 80 * scale;
            
            // Font Sizes (Dynamic)
            const fontSizeLabel = BASE_FONT_LABEL * scale;
            const fontSizeDate = BASE_FONT_DATE * scale;
            const fontSizeAddr = BASE_FONT_ADDR * scale;

            // Text Content
            const txtTime = timeLabelInput.value || "TIME";
            const txtDate = dateLabelInput.value || "DATE";
            const txtAddr = addressLabelInput.value || "ADDRESS";
            const colAccent = accentColorInput.value;
            const colBg = bgCardColorInput.value;
            const colText = textColorInput.value;

            // Positioning (Bottom Left)
            const startX = padding;
            const bottomY = canvas.height - padding;

            // Estimate Height
            const lineHeightTime = fontSizeLabel * 1.2;
            const lineHeightDate = fontSizeDate * 1.2;
            const lineHeightAddr = fontSizeAddr * 1.3;
            const contentH = lineHeightTime + (20 * scale) + lineHeightDate + (15 * scale) + lineHeightAddr;
            const cardHeight = contentH + (cardPadding * 2);
            const cardTopY = bottomY - cardHeight;

            // Shadow
            ctx.save();
            ctx.shadowColor = "rgba(0, 0, 0, 0.25)";
            ctx.shadowBlur = 30 * scale;
            ctx.shadowOffsetY = 15 * scale;

            // Card Background
            ctx.fillStyle = colBg;
            roundRect(ctx, startX, cardTopY, cardWidth, cardHeight, 20 * scale);
            ctx.fill();
            ctx.restore();

            // Accent Line
            ctx.fillStyle = colAccent;
            roundRect(ctx, startX + cardPadding, cardTopY + cardPadding + (10 * scale), lineWidth, accentLineHeight, lineWidth/2);
            ctx.fill();

            // Text Settings
            ctx.fillStyle = colText;
            ctx.textBaseline = 'top';

            // 1. Time Label Tag
            ctx.font = `bold ${fontSizeLabel}px ${FONT_FAMILY}`;
            const timeMetrics = ctx.measureText(txtTime);
            const tagX = startX + cardPadding + (25 * scale);
            const tagY = cardTopY + cardPadding;
            const tagW = timeMetrics.width + (40 * scale);
            const tagH = lineHeightTime;

            ctx.fillStyle = colAccent; // Background for tag
            roundRect(ctx, tagX, tagY, tagW, tagH, 12 * scale);
            ctx.fill();

            // Time Text
            ctx.fillStyle = "#ffffff"; 
            // Check contrast logic if needed, but white on yellow/black is usually fine.
            ctx.fillText(txtTime, tagX + (20 * scale), tagY + ((lineHeightTime - fontSizeLabel)/2));

            // 2. Date
            ctx.fillStyle = colText;
            ctx.font = `${fontSizeDate}px ${FONT_FAMILY}`;
            const dateY = tagY + lineHeightTime + (20 * scale);
            ctx.fillText(txtDate, startX + cardPadding + (25 * scale), dateY);

            // 3. Address
            ctx.font = `${fontSizeAddr}px ${FONT_FAMILY}`;
            const addrY = dateY + lineHeightDate + (15 * scale);
            const maxTextW = cardWidth - (cardPadding * 2) - (25 * scale);
            wrapText(ctx, txtAddr, startX + cardPadding + (25 * scale), addrY, maxTextW, lineHeightAddr);
        }

        // Helper: Rounded Rect
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // Helper: Text Wrap
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y;

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    ctx.fillText(line, x, currentY);
                    line = words[n] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, currentY);
        }

        function downloadImage() {
            if (!currentImage) return;
            loadingOverlay.style.display = 'flex';
            
            setTimeout(() => {
                try {
                    const link = document.createElement('a');
                    link.download = `geotag-big-${Date.now()}.jpg`;
                    link.href = canvas.toDataURL('image/jpeg', 0.95);
                    link.click();
                    showToast('Image downloaded!');
                } catch (e) {
                    showToast('Download failed.');
                } finally {
                    loadingOverlay.style.display = 'none';
                }
            }, 100);
        }

        function showToast(msg) {
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>
```
